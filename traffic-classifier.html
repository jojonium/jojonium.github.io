<!doctype html>
<html lang="en-US">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>Traffic Classifier</title>
    <meta name="description" content="A project for CS 4516: Advanced Computer Networks, involving setting up a GNU/Linux virtual machine gateway to capture encrypted packets from a subnet and use machine learning to classify which application they came from" />
    <meta property="og:title" content="Traffic Classifier" />
    <meta property="og:description" content="A project for CS 4516: Advanced Computer Networks, involving setting up a GNU/Linux virtual machine gateway to capture encrypted packets from a subnet and use machine learning to classify which application they came from" />
    <meta property="og:image" content="https://josephpetitti.com/images/virtualbox-config.png" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://josephpetitti.com/traffic-classifier" />
    <meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, width=device-width, user-scalable=no" />
    <link rel="shortcut icon" href="icon.ico" type="image/x-icon">

    <link rel="stylesheet" href="webfonts/fonts.css" type="text/css">
    <link rel="stylesheet" href="styles/fontawesome.min.css" type="text/css">
    <link rel="stylesheet" href="styles/brands.css" type="text/css">
    <link rel="stylesheet" href="styles/solid.min.css" type="text/css">
    <link href="styles/dark.css" rel="stylesheet" type="text/css">
  </head>
  <body>

  <script>
    const showNav = function() {
      document.getElementById('nav').classList.add("shown");
    }
    const closeNav = function() {
      document.getElementById('nav').classList.remove("shown");
    }
  </script>

  <!-- Header -->
    <header>
      <a id="mobile-nav" href="javascript:showNav()" title="Navigation">
        <i class="fas fa-bars"></i> Menu
      </a>
    <!-- Nav -->
      <nav id="nav">
        <a id="mobile-nav-close" href="javascript:closeNav()" title="Close">
          <i class="fas fa-times"></i> Close
        </a>
        <ul>
          <li><a href="index">Home</a></li>
          <li><a href="resume">Resume</a></li>
          <li><a href="projects">Projects</a>
            <ul>
			  <li><a href="hong-kong-historic-conservation">Hong Kong Historic <br> Conservation</a></li>
              <li><a href="meeting-scheduler">Algol Meeting Scheduler</a></li>
              <li><a href="this-website">This Website</a></li>
              <li><a href="http-server-client">HTTP Server & Client</a></li>
              <li><a href="process-statistics">Process Statistics</a></li>
              <li><a href="tic-tac-toe">Tic-Tac-Toe</a></li>
            </ul>
          </li>
          <li><a href="blog">Blog</a>
          <li><a href="other">Other</a>
            <ul>
              <li><a href="dice">Dice</a></li>
              <li><a href="ant">Langton's Ant</a></li>
              <li><a href="rps">RPS Automaton</a></li>
              <li><a href="type">Typing Game</a></li>
              <li><a href="minesweeper">Minesweeper</a></li>
              <li><a href="snake">Snake</a></li>
              <li><a href="match">Color Match</a></li>
              <li><a href="klotski">Klotski</a></li>
              <li><a href="sliding-tetris">Sliding Tetris</a></li>
            </ul>
          </li>
        </ul>
      </nav>


    </header>

  <!-- Main -->
    <main id="main">

      <h1 class="title"> TRAFFIC CLASSIFIER </h1>

      <div class="main-links-holder long-buttons">
        <a href="https://github.com/jojonium/CS-4516-Advanced-Computer-Networks" target=_blank">
          <button class="long">
            <span class="fab fa-github"></span> Github
          </button>
        </a>
      </div>

      <h2 id="overview">Overview</h2>

      <p>
        For this project for CS 4516: Advanced Computer Networks, I worked with
        a partner to set up a network of virtual machines in which a TinyCore
        GNU/Linux VM acts as an IP gateway for an Android 6.0 VM. The gateway
        captures packets from the Android VM, analyzes them, and uses a random
        forest classifier to predict what application they game from, even
        though the packet payloads are encrypted.
      </p>

      <p>
        This project involved dozens of hours of work over six weeks, and lots
        of independent development and research. Neither I nor my partner had
        any experience with machine learning, so we had to learn how to make
        that part of the project work on our own.
      </p>

      <hr>

      <h2 id="phase-1">Phase 1</h2>

      <p>
        In this phase, we configured the TinyCore VM to act as a gateway. We set
        up an SSH connection to the virtual machine from the host machine and
        configured the Android x86 6.0 and TinyCore VMs to work on the same
        virtual network.
      </p>

      <figure class="full-width">
        <img src="images/virtualbox-config.png" alt="VirtualBox configuration"/>
        <figcaption>VirtualBox network configuration</figcaption>
      </figure>

      <h3 id="ip-gateway">IP Gateway</h3>

      <p>
        Next, we configured the eth1 interface of TinyCore to have the static IP
        address 192.168.12.1, netmask 255.255.255.0. This is the interface it
        uses to connect to the Internet. TinyCore's other (virtual) interface,
        eth0, will be hooked up to the Android VM. We also used iptables to
        route packets from eth0 to the Internet and back. Now TinyCore can act
        like a gateway middlebox.
      </p>

      <h3 id="dhcp-server">DHCP Server</h3>

      <p>
        We also wanted TinyCore to act as a DHCP server for its subnet. We used
        the program udhcpd with this configuration file to do that:
      </p>

      <div class="code">start 192.168.12.100
end 192.168.12.200
interface eth1
option subnet 255.255.255.0
option router 192.168.12.1
option lease 43200
option dns 10.0.2.3       # the address of VirtualBox&#39;s DNS server
option domain network2</div>

      <h3 id="startup-script">Startup Script</h3>

      <p>
        Finally, we needed to persist these changes so they apply every time the
        TinyCore VM reboots. We wrote this script, 
        <span class="code">/opt/eth1.sh</span>, to run at startup and apply all
        the configurations. This script kills the udhcpc process if it's already
        running, configures eth1 interface, and then starts the udhcpc server
        process.
      </p>

      <div class="code"><span style='color:#9999a9; '>#! </span><span style='color:#007997; '>/bin/sh</span>

<span style='color:#9999a9; '># kill dhcp client for eth1</span>
<span style='color:#e66170; font-weight:bold; '>if</span> <span style='color:#d2cd86; '>[</span> <span style='color:#00dddd; '>-f</span> <span style='color:#3066be; '>/var/run/udhcpc.eth1.pid</span> <span style='color:#d2cd86; '>]</span><span style='color:#b060b0; '>;</span> <span style='color:#e66170; font-weight:bold; '>then</span>
    <span style='color:#904050; '>kill</span> <span style='color:#ffffff;'>`cat </span><span style='color:#3066be;'>/var/run/udhcpc.eth1.pid</span><span style='color:#ffffff;'>`</span>
    sleep <span style='color:#008c00; '>0</span><span style='color:#e66170; font-weight:bold; '>.</span><span style='color:#008c00; '>1</span>
<span style='color:#e66170; font-weight:bold; '>fi</span>

<span style='color:#9999a9; '># configure interface eth1</span>
ifconfig eth1 <span style='color:#008c00; '>192</span><span style='color:#e66170; font-weight:bold; '>.</span><span style='color:#008c00; '>168</span><span style='color:#e66170; font-weight:bold; '>.</span><span style='color:#008c00; '>12</span><span style='color:#e66170; font-weight:bold; '>.</span><span style='color:#008c00; '>1</span> netmask <span style='color:#008c00; '>255</span><span style='color:#e66170; font-weight:bold; '>.</span><span style='color:#008c00; '>255</span><span style='color:#e66170; font-weight:bold; '>.</span><span style='color:#008c00; '>255</span><span style='color:#e66170; font-weight:bold; '>.</span><span style='color:#008c00; '>0</span> broadcast <span style='color:#008c00; '>192</span><span style='color:#e66170; font-weight:bold; '>.</span><span style='color:#008c00; '>168</span><span style='color:#e66170; font-weight:bold; '>.</span><span style='color:#008c00; '>12</span><span style='color:#e66170; font-weight:bold; '>.</span><span style='color:#008c00; '>255</span> up

<span style='color:#9999a9; '># start the DHCP server process in the background once the interface is ready</span>
sudo udhcpd <span style='color:#3066be; '>/etc/eth1_udhcpd.conf</span> <span style='color:#b060b0; '>&amp;</span></div> 

      <hr>

      <h2 id="phase2">Phase 2</h2>

      <p>
        For this phase, we wrote a Python script called
        <span class="code">logFlows</span> that captures packets from the
        Android VM and separates them into bursts and flows. A flow is defined
        as a sequence of packets with the same source IP, source port,
        destination IP, and destination port. A burst is a group of flows
        separated by gaps of greater than one second of silence. After each
        burst, the program prints a report on which each flow in that burst, in
        the following format:
      </p>

      <div class="code">&lt;timestamp&gt; &lt;src addr&gt; &lt;dst addr&gt; &lt;src port&gt; &lt;dst port&gt; &lt;proto&gt; \
&lt;#packets sent&gt; &lt;#packets rcvd&gt; &lt;#bytes send&gt; &lt;#bytes rcvd&gt;</div> 

      <p>
        Timestamps are measured in seconds since the program was started, and
        represent the time of arrival of the last pack in the flow.
      </p>

      <p>
        <span class="code">logFlows</span> uses Python 2 and requires the Python
        package scapy, which can be easily installed with pip. Note that it must
        be run as root on TinyCore.
      </p>
      
      <hr>

      <h2 id="phase-3">Phase 3</h2>

      <p>To run this program, run:</p>
        
      <div class="code">./classifyFlows <i>filename.pcap</i></div>

      <p>
        where <span class="code">filename.pcap</span> is a PCAP packet capture
        trace. It will identify all flows in this trace and attempt to identify
        which application they are from. At the end it will print summary
        statistics including the percentage identified as each app.
      </p>

      <h3 id="python-packages">Python Packages</h3>

      <p>We used Python 3 for this phase. Required packages:</p>

      <ul>
        <li>scipy</li>
        <li>kamene</li>
        <li>scikit-learn</li>
        <li>numpy</li>
        <li>pickle</li>
      </ul>

      <h3 id="classification-vectors">Classification Vectors</h3>

      <p>
        Our classification model is a random forest classifier generated by
        creating feature vectors from test flows with the following
        information:
      </p>

      <ul>
        <li>Byte ratio (bytes sent / bytes received, or reciprocal)</li>
        <li>Packet ratio (packets sent / packets received, or reciprocal)</li>
        <li>Mean packet length</li>
        <li>Standard deviation of packet lengths (zero if n &lt;= 2)</li>
        <li>Packet length kurtosis</li>
        <li>Packet length skew</li>
        <li>Mean time gap between each packet (zero if n &lt;= 1)</li>
        <li>Time gap kurtosis</li>
        <li>Time gap skew</li>
        <li>Min packet length</li>
        <li>Max packet length</li>
        <li>Min time gap</li>
        <li>Max time gap</li>
        <li>Protocol (1 for TCP, 0 for UDP)</li>
      </ul>

      <h3 id="file-breakdown">File Breakdown</h3>

      <p>
        <span class="code">pcapper.py</span> runs on TinyCore, captures packets
        from eth1 and writes them as PCAP files.
        <span class="code">trainer.py</span> builds the classification model
        based on feature vectors that we collected. It takes in two or more
        pickled python objects representing the feature vectors and uses them to
        build the model.  It will continue to train an existing
        <span class="code">model.pkl</span> file if one exists, or will create
        one otherwise. <span class="code">classifyFlows</span> requires
        <span class="code">model.pkl</span> to be in the same directory. It
        takes in a PCAP file as an argument and classifies each of the flows in
        it based on the <span class="code">model.pkl</span>. It then makes a
        prediction about what application the flow came from and prints it in
        the following format:
      </p>

      <div class="code">&lt;timestamp&gt; &lt;src addr&gt; &lt;dst addr&gt; &lt;src port&gt; &lt;dst port&gt; &lt;proto&gt; \
&lt;#packets sent&gt; &lt;#packets rcvd&gt; &lt;#bytes send&gt; &lt;#bytes rcvd&gt; &lt;label&gt;</div>

      <p>
        A modified version of <span class="code">classifyFlows</span> was also
        used to build vectors out of PCAP files to feed to
        <span class="code">trainer.py</span>.
      </p>

      <p>
        We didn't include the PCAP and feature vector files we used for testing
        and training to conserve space and fit within Canvas's upload limit.
      </p>

      <h3 id="results">Results</h3>

      <p>
        The following table shows the results of our test. The second column
        shows the percentage of flows that were correctly identified, excluding
        flows identified as unknown.
      </p>

      <table>
        <thead class="header">
          <tr>
            <th>Application Name</th>
            <th class="r">% Correct</th>
            <th class="r">% Unknown</th>
          </tr>
        </thead>
        <tbody>
          <tr class="odd">
            <th>YouTube</th>
            <td class="r">79.94%</td>
            <td class="r">11.39%</td>
          </tr>
          <tr class="even">
            <th>Browser</th>
            <td class="r">20.53%</td>
            <td class="r">34.48%</td>
          </tr>
          <tr class="odd">
            <th>Google News</th>
            <td class="r">36.13%</td>
            <td class="r">24.44%</td>
          </tr>
          <tr class="even">
            <th>Fruit Ninja</th>
            <td class="r">53.33%</td>
            <td class="r">11.76%</td>
          </tr>
          <tr class="odd">
            <th>Weather Channel</th>
            <td class="r">55.84%</td>
            <td class="r">20.10%</td>
          </tr>
          <tr class="even" style="color: #eee">
            <th><strong>Average</strong></th>
            <td class="r"><strong>50.15%</strong></td>
            <td class="r"><strong>20.43%</strong></td>
          </tr>
        </tbody>
      </table>

      <p>
        For each application, our model was more accurate than simply guessing
        (20%). Overall, it is correct more often that not.
      </p>

      <h3 id="limitations-and-shortcomings">Limitations and Shortcomings</h3>

      <p>
        For some reason our model really likes misidentifying flows as being
        from the Weather Channel app. We hypothesize that the Weather Channel's
        app performs a variety of network applications including video,
        advertisements, and asynchronous data requests, which makes it easy to
        confuse with other apps. Our machine learning model is also probably not
        ideal because neither of us have taken a machine learning class.
      </p>

      <hr>

      <h2 id="phase-4">Phase 4</h2>

      <p>
        For this phase we combined all the previous phases to make a complete
        project. We retrained the model from Phase 3 to work on 32-bit TinyCore,
        and set it up to run continuously on the VM. It captured live packets
        from the Android VM and classified them in real time, writing the
        results of each classification to a log.
      </p>

      <p>
        This project shows how traffic classification is still possible despite
        the use of encryption. Even without knowing anything about packet
        payloads we were able to correctly identify which application a packet
        flow came from a decent percentage of the time. With more time and
        machine learning experience we could likely get this accuracy higher.
      </p>

      <p>
        Even without knowing the specific contents of packets, there's a lot you
        can do with this information. For example, you could selectively block
        particular applications, or know what shady apps a surveilled political
        opponent is using. Regardless, this project shows that even end-to-end
        encryption is not the perfect security solution.
      </p>
    </main>

  <!-- Footer -->
    <footer id="footer">
      <section class="about">
        <h2>About this website</h2>
        <p>
          I created this website as a personal project in my free time to learn
          more about web design, CSS, HTML, and JavaScript.
        </p>
        <p>
          All portions of this website written by me are released under the
          <a href="license.txt"> MIT License</a>. Other scripts and resources
          are licensed under free licenses by their respective owners. All
          source code is available on
          <a href="https://github.com/jojonium/josephpetitti.com">GitHub</a>.
        </p>
      </section>
      <section class="contact">
        <h2>Contact Information</h2>
        <dl>
          <dt>Address</dt>
            <dd>100 Institute Road, Mailbox #2658 Worcester, MA 01609</dd>
          <dt>Phone</dt>
            <dd>(518) 545-1984</dd>
          <dt>Email</dt>
            <dd><a href="mailto:jppetitti@wpi.edu">jppetitti@wpi.edu</a></dd>
        </dl>
        <ul class="icons">
          <li><a href="https://github.com/jojonium" target="_blank"><span class="fab fa-github" title="GitHub"></a></li>
          <li><a href="https://www.linkedin.com/in/joseph-petitti/" target="_blank"><span class="fab fa-linkedin" title="LinkedIn"></a></li>
          <li><a href="https://steamcommunity.com/id/thedungeonmaster/" target="_blank"><span class="fab fa-steam" title="Steam"></a></li>
          <li><a href="https://t.me/jojonium" target="_blank"><span class="fab fa-telegram" title="Telegram"></a></li>
        </ul>
      </section>
    </footer>
  </body>
</html>
